# 垃圾收集器与内存分配策略

## 3.1 概述

GC需要完成三件事：

1. 哪些内存需要回收?
2. 什么时候回收?
3. 如何回收?

> 第二章介绍了Java内存运行时区域的各个部分。
>
> **程序计数器、虚拟机栈、本地方法栈**三个区域随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧需要分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但是大体上可以认为是编译器可知的），因此在这几个区域的内存分配和回收都具有确定性，这几个区域不太需要过多地考虑回收的问题。
>
> 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分的内存分配和回收都是动态的，垃圾收集器需要关注的是这部分内存，我们所讨论的“内存”分配与回收也仅仅指着一部分。

## 3.2 对象已死?

### 3.2.1 引用计数法

很难解决对象之间的相互循环引用的问题。

### 3.2.2 可达性分析算法*Reachability Analysis*

基本思路是：通过一系列的名字为**GC Roots**的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（*Reference Chain*），当一个对象到GC Roots没有任何引用链对象相连（用图论的话说，就是从GC Roots到这个对象不可到达）时，则证明此对象不可用。

![Reachability Analysis](https://cdn.jsdelivr.net/gh/Clarencezero/poi/gc root.png)

在Java语言中，可作为GC Roots的对象包括下面几种:

- 虚拟机**栈**（栈中的本地变量表）中的引用的对象
- **方法区**中的类静态属性引用的对象
- **方法区**中的常量引用的对象
- 本地方法栈中JNI（即一般说的Native方法）的引用的对象

### 3.2.3 再谈引用

JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。

1. 强引用

   被强引用关联的对象不会被回收。 使用 new 一个新对象的方式来创建强引用。
   ```java
   Object obj = new Object();
   ```

   这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。 

2. 软引用

   被软引用关联的对象只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。用来描述一些还有用，但是并非必需的对象。

   在系统将要发生内存溢出异常之前，将会把这些对象放进回收范围之中并进行第二次的回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。

   ```java
   Object obj = new Object();
   SoftReference<Object> sf = new SoftReference<Object>(obj);
   obj = null;  // 使对象只被软引用关联
   ```

3. 弱引用

   被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。 
   
   当垃圾回收器工作时，不论当前内存是否足够，都会回收掉只被弱引用关联的对象。
   
   使用 WeakReference 类来创建弱引用。
   
   ```java
   Object obj = new Object();
   WeakReference<Object> wf = new WeakReference<Object>(obj);
   obj = null;
   ```

4. 虚引用

   也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不影响其生存时间，也无法通过虚引用来获取一个对象的实例。

   为一个对象设置虚引用的唯一目的就是希望这个对象被收集器回收时收到一个系统通知。

   在JDK1.2之后，提供了PhantomReference类来实现虚引用。

   ```java
   Object obj = new Object();
   PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
   obj = null;
   ```

### 3.2.4 生存还是死亡?

要真正宣告对象的死亡，至少要经历两次标记：

如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它就会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行finalize()方法，那么这个对象就会被放在名为F-Queue的队列中，并在稍后有一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所说的“执行”是指虚拟机会触发这个方法，但是并不承诺会保证等待它运行结束。（这样做的目的是，如果一个对象在finalize()方法中执行缓慢或者是发生了死循环，将可能会导致F-Queue里的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃）。 finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()方法中成功拯救自己，只要重新与引用链上的任何对象建立关联即可，譬如把自己（this关键字）复制给某个类变量或者对象的成员变量。

它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。

### 3.2.5 回收方法区

**Q:**方法区与永久代的关系?

很多文章里喜欢把方法区等同与永久代，永久代既然没了，方法区也就没了。但我认为方法区只是一种逻辑上的概念，永久代指物理上的堆内存的一块空间，这块实际的空间完成了方法区存储字节码、静态变量、常量的功能等等。既然如此，现在元空间也可以认为是新的方法区的实现了。

**Q:**常量池随永久代的变化

常量池分以下几种:

1. 静态常量池。

   即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串/数字这些字面量，还包含类、方法的信息，占用class文件绝大部分空间。这种常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等；符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名、字段名称描述符、方法名称描述符。 

   类的加载过程中的链接部分的解析步骤就是把符号引用替换为直接引用，即把那些描述符（名字）替换为能直接定位到字段、方法的引用或句柄（地址）。

2. 运行时常量池。

   而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 运行时常量池相对于CLass文件常量池的另外一个重要特征是**具备动态性**，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String类的intern()**方法。 

常量池的好处

1. 节省内存空间: 常量池中所有相同的字符串常量被合并，只占用一个空间
2. 节省运行时间: 比较字符串时，`==` 比`equals()`快。只用`==`判断引用是否相等，也就可以判断实际值是否相等。

```java
String s1 = "hello";
String s2 = "hello";
System.out.println(s1 == s2); // true
```

编译期间，字面量会直接放入`class`文件的常量池中，从而实现Class领域内的复用。载入运行时常量池后，s1、s2指向的是同一个内存地址。

```java
String s3 = "hel" + "lo";
String s4 = "hel" + new String("lo");
System.out.println(s1 == s3);  // true
System.out.println(s1 == s4);  // false
```

s3虽然是拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化。因此，在class文件中s3存储为`hello`。所以`s1==s3`为true。
**只有使用引号包含文本的方式创建的String对象之间使用`+`连接产生的新对象才会被加入字符串池中。**

s1和s4当然不对等。s4虽然也是拼接出来，但是对于`new String("lo");`这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果。所以不清楚s4分配的地址是在哪里，所以地址肯定不同。

```java
String s5 = new String("hello");
String s6 = s5.intern();
System.out.println(s1 == s6);  // true
```

intern方法会尝试将`hello`字符串添加到常量池中，并返回其在常量池中的地址。因为常量池中已经存在了hello字符串，所以intern方法直接返回地址。

结论: 

1. 必须关注编译期的行为，才能更好的理解常量池。
2. 运行时常量池中的常量，基本来源于各个class文件中的常量池。
3. 程序运行时，除非手动向常量池中添加常量(比如`intern`方法)，否则JVM不会自动添加常量到常量池。

Byte,Short,Integer,Long,Character,Boolean 这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 










