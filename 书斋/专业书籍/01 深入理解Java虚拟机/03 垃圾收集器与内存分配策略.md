# 垃圾收集器与内存分配策略

## 3.1 概述

GC 需要完成三件事：

1. 哪些内存需要回收?
2. 什么时候回收?
3. 如何回收?

> 第二章介绍了 Java 内存运行时区域的各个部分。
>
> **程序计数器、虚拟机栈、本地方法栈**三个区域随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧需要分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化，但是大体上可以认为是编译器可知的），因此在这几个区域的内存分配和回收都具有确定性，这几个区域不太需要过多地考虑回收的问题。
>
> 而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分的内存分配和回收都是动态的，垃圾收集器需要关注的是这部分内存，我们所讨论的“内存”分配与回收也仅仅指着一部分。

## 3.2 对象已死?

### 3.2.1 引用计数法

很难解决对象之间的相互循环引用的问题。

### 3.2.2 可达性分析算法*Reachability Analysis*

基本思路是：通过一系列的名字为**GC Roots**的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（*Reference Chain*），当一个对象到 GC Roots 没有任何引用链对象相连（用图论的话说，就是从 GC Roots 到这个对象不可到达）时，则证明此对象不可用。

![Reachability Analysis](https://cdn.jsdelivr.net/gh/Clarencezero/poi/gc root.png)

在 Java 语言中，可作为 GC Roots 的对象包括下面几种:

- 虚拟机**栈**（栈中的本地变量表）中的引用的对象
- **方法区**中的类静态属性引用的对象
- **方法区**中的常量引用的对象
- 本地方法栈中 JNI（即一般说的 Native 方法）的引用的对象

### 3.2.3 再谈引用

JDK1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。

1. 强引用

   被强引用关联的对象不会被回收。 使用 new 一个新对象的方式来创建强引用。
   ```java
   Object obj = new Object();
   ```

   这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。 

2. 软引用

   被软引用关联的对象只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。用来描述一些还有用，但是并非必需的对象。

   在系统将要发生内存溢出异常之前，将会把这些对象放进回收范围之中并进行第二次的回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。

   ```java
   Object obj = new Object();
   SoftReference<Object> sf = new SoftReference<Object>(obj);
   obj = null;  // 使对象只被软引用关联
   ```

3. 弱引用

   被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。 
   
   当垃圾回收器工作时，不论当前内存是否足够，都会回收掉只被弱引用关联的对象。
   
   使用 WeakReference 类来创建弱引用。
   
   ```java
   Object obj = new Object();
   WeakReference<Object> wf = new WeakReference<Object>(obj);
   obj = null;
   ```

4. 虚引用

   也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不影响其生存时间，也无法通过虚引用来获取一个对象的实例。

   为一个对象设置虚引用的唯一目的就是希望这个对象被收集器回收时收到一个系统通知。

   在 JDK1.2 之后，提供了 PhantomReference 类来实现虚引用。

   ```java
   Object obj = new Object();
   PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
   obj = null;
   ```

### 3.2.4 生存还是死亡?

要真正宣告对象的死亡，至少要经历两次标记：

如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它就会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象就会被放在名为 F-Queue 的队列中，并在稍后有一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所说的“执行”是指虚拟机会触发这个方法，但是并不承诺会保证等待它运行结束。（这样做的目的是，如果一个对象在 finalize() 方法中执行缓慢或者是发生了死循环，将可能会导致 F-Queue 里的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃）。 finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模标记，如果对象要在 finalize() 方法中成功拯救自己，只要重新与引用链上的任何对象建立关联即可，譬如把自己（this 关键字）复制给某个类变量或者对象的成员变量。

它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。

### 3.2.5 回收方法区

**Q:**方法区与永久代的关系?

很多文章里喜欢把方法区等同与永久代，永久代既然没了，方法区也就没了。但我认为方法区只是一种逻辑上的概念，永久代指物理上的堆内存的一块空间，这块实际的空间完成了方法区存储字节码、静态变量、常量的功能等等。既然如此，现在元空间也可以认为是新的方法区的实现了。

**Q:**常量池随永久代的变化

常量池分以下几种:
1. 静态常量池。
   即*.class 文件中的常量池，class 文件中的常量池不仅仅包含字符串/数字这些字面量，还包含类、方法的信息，占用 class 文件绝大部分空间。这种常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于 Java 语言层面常量的概念，如文本字符串，声明为 final 的常量值等；符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名、字段名称描述符、方法名称描述符。 

   类的加载过程中的链接部分的解析步骤就是把符号引用替换为直接引用，即把那些描述符（名字）替换为能直接定位到字段、方法的引用或句柄（地址）。

2. 运行时常量池。
   而运行时常量池，则是 jvm 虚拟机在完成类装载操作后，将 class 文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 运行时常量池相对于 CLass 文件常量池的另外一个重要特征是**具备动态性**，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 CLass 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String 类的 intern()**方法。 

常量池的好处
1. 节省内存空间: 常量池中所有相同的字符串常量被合并，只占用一个空间
2. 节省运行时间: 比较字符串时，`==` 比`equals()`快。只用`==`判断引用是否相等，也就可以判断实际值是否相等。

```java
String s1 = "hello";
String s2 = "hello";
System.out.println(s1 == s2); // true
```

编译期间，字面量会直接放入`class`文件的常量池中，从而实现 Class 领域内的复用。载入运行时常量池后，s1、s2 指向的是同一个内存地址。

```java
String s3 = "hel" + "lo";
String s4 = "hel" + new String("lo");
System.out.println(s1 == s3);  // true
System.out.println(s1 == s4);  // false
```

s3 虽然是拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化。因此，在 class 文件中 s3 存储为`hello`。所以`s1==s3`为 true。
**只有使用引号包含文本的方式创建的 String 对象之间使用`+`连接产生的新对象才会被加入字符串池中。**

s1 和 s4 当然不对等。s4 虽然也是拼接出来，但是对于`new String("lo");`这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果。所以不清楚 s4 分配的地址是在哪里，所以地址肯定不同。

```java
String s5 = new String("hello");
String s6 = s5.intern();
System.out.println(s1 == s6);  // true
```

intern 方法会尝试将`hello`字符串添加到常量池中，并返回其在常量池中的地址。因为常量池中已经存在了 hello 字符串，所以 intern 方法直接返回地址。

结论: 

1. 必须关注编译期的行为，才能更好的理解常量池。
2. 运行时常量池中的常量，基本来源于各个 class 文件中的常量池。
3. 程序运行时，除非手动向常量池中添加常量 (比如`intern`方法)，否则 JVM 不会自动添加常量到常量池。

Byte,Short,Integer,Long,Character,Boolean 这 5 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 

## 3.3 垃圾收集算法

### 3.3.1 标记-清除算法

![标记-清除 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/标记-清除.png)

在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。

在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

### 3.3.2 复制算法

![复制 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/复制.png)

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

### 3.3.3 标记-整理算法

![标记-整理 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/标记-整理.png)

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点:

- 不会产生内存碎片

不足:

- 需要移动大量对象，处理效率比较低。

### 3.3.4 分代收集算法

当前商业虚拟机的垃圾收集都是采用“分代收集（Generational Collection）算法”，根据对象的存活周期的不同将内存划分为几块。 一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特定采用最适当的收集算法。在新生代，每次垃圾收集都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成省收集。而老年代中因为对象存活率高，没有额外的空间进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。



## 3.4 HotSpot 的算法实现

### 3.4.1 枚举根节点

虚拟机应当是有办法直接得知哪些地方存放着对象引用。在 HotSpot 的实现中,是使用一组称为 OopMap 的数据结构来达到这个目的。

在类加载完成的时候,HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来,在 JIT 编译过程中,也会在特定的位置记录下栈和寄存器中哪些位置是引用。

### 3.4.2 安全点

**Q:**OopMap 内容变化指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的空间，这样 GC 的空间成本将会变得更高。

实际上，HotSpot 也的确没有为每条指令都生成 OopMap，只在特定的位置记录了这些信息，这些位置称为安全点`Saftpoint`，即程序执行时并非在所有地方都能停顿下来开始 GC，只有到达安全点时才能暂停。

安全点的选择基本是以程序是否具有让程序长时间执行的特征"为标准进行选定。长时间执行的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等。所以具有这些这些功能的指令都会产生 safepoint。

**主动式中断**: 当 GC 需要中断线程的时候,不直接对线程操作,仅仅简单地设置一个标志,各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的,另外再加上创建对象需要分配内存的专访。

## 3.5 垃圾收集器

![HotSpot 7 个垃圾收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/垃圾收集器.jpg)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

### 3.5.1. Serial 收集器

![Serial 收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/Serial-收集器.jpg)

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

### 3.5.2. ParNew 收集器

![ParNew 收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/ParNew-收集器.jpg)

它是 Serial 收集器的多线程版本。

它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

### 3.5.3. Parallel Scavenge 收集器

与 ParNew 一样是多线程收集器。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

### 3.5.4. Serial Old 收集器

![Serial Old 收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/Serial-old 收集器.jpg)

是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### 3.5.5. Parallel Old 收集器

![Parallel Old](https://cdn.jsdelivr.net/gh/Clarencezero/poi/Parallel-Old-收集器.jpg)

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### 3.5.6. CMS 收集器

![CMS 收集器 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/CMS-收集器.jpg)

CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程：

- 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中**耗时最长**，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除：不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

### 3.5.7. G1 收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 

![G1 Heap Allocation](https://cdn.jsdelivr.net/gh/Clarencezero/poi/G1-收集器 2.png) 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![G1 垃圾回收 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi/G1-收集器 3.jpg)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

### 3.5.8 理解 GC 日志

### 3.5.9 垃圾收集器参数总结

## 3.6 内存分配与回收策略

### 3.6.1 对象优先在 Eden 分配

 大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 **Minor GC**。 

### 3.6.2 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

```shell
-XX:PretenureSizeThreshold
```

大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

### 3.6.3 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

```shell
-XX:MaxTenuringThreshold
```

 用来定义年龄的阈值。

### 3.6.4 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 

### 3.6.5 空间分配担保

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

## 3.7 Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： 

### 3.7.1. 调用 System.gc()

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

### 3.7.2. 老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过

```shell
 -XX:MaxTenuringThreshold
```

 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

### 3.7.3. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。

### 3.7.4. JDK 1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

### 3.7.5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。










